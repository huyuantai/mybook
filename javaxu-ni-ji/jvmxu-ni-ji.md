JVM 线上故障排查基本操作


# 为什么要进行分代回收
不同的对象，生命周期是不一样的。因此不同生命周期的对象采用不同的收集方式。可以提高垃圾回收的效率。

在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，
比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，
因此生命周期比较长。

但是还有一些对象，主要是程序运行过程中生成的临时变量，
这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，
系统会产生大量的这些对象，有些对象甚至只用一次即可回收。

如果不分代的话，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。

因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收


# 新生代为什么要用复制算法，老年代为什么用标记清除、标记整理


在新生代，每次垃圾收集时都有大量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

在老年代，对象存活率高，没有额外空间对它进行分配担保，就必须只有标记-清除和标记-整理算法来进行回收


# 为什么要用两个Survivor

Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，
Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代


设置两个Survivor区最大的好处就是解决了碎片化

Eden满时Minor GC，Eden中的存活对象移动 S0，Eden被清空；
Eden区再满Minor GC，Eden和S0中的存活对象 移到S1
Eden区又满Minor GC，Eden和S1中的存活对象 移到S0 (S1、S0调转)

因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。

# 只使用一个Survivor会碎片化
![](/assets/20160516173704870)

# 使用两个Survivor得以解决
![](/assets/20160516174938778)