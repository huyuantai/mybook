# 创建型模式

### 1.单例模式

##### 定义
单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，提供全局访问

##### 解决问题（为什么使用单例模式）
一则解决多线程并发访问的问题，避免对资源的多重占用、同时操作
二则节约CPU资源及内存资源，提交系统运行的效率，提高系统性能

##### 优点
* 提供了对唯一实例的受控访问；
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；
* 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式；

##### 缺点
* 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。
* 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失

##### 适用场景
* 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
* 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

#####  使用场景，项目中使用
程序的日志应用、配置对象的读取、数据库连接池、线程池、负载均衡器、工具类
缓存、日志对象、对话框、打印机、显卡的驱动程序对象

项目中有个打印面单的功能，设计就是单例模式，不能起两个打印程序


### 2.简单工厂
##### 定义
在简单工厂模式中，可以根据参数的不同返回不同类的实例

##### 解决问题
将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易，从而避免了在客户端代码中显式指定，实现了解耦

##### 优点
* 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
* 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
##### 缺点
* 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
* 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
* 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构

##### 应用场景
* 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；
* 当工厂类负责创建的对象（具体产品）比较少时

### 3.工厂模式
##### 定义
通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象

##### 作用
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类

##### 解决的问题
解决简单工厂添加新产品得修改工厂类，违背了开放关闭原则的问题

##### 优点
* 更符合开-闭原则
新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构。
简单工厂模式的工厂类使用静态工厂方法

* 总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

##### 缺点
* 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
* 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
* 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
一个具体工厂只能创建一种具体产品




### 4.抽象工厂

##### 定义
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

##### 作用
工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品

##### 优点
当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

##### 缺点
在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便








