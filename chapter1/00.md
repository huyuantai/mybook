# 创建型模式

### 1.单例模式

##### 定义
单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，提供全局访问

##### 解决问题（为什么使用单例模式）
一则解决多线程并发访问的问题，避免对资源的多重占用、同时操作
二则节约CPU资源及内存资源，提交系统运行的效率，提高系统性能

##### 优点
* 提供了对唯一实例的受控访问；
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；
* 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式；

##### 缺点
* 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。
* 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失

##### 适用场景
* 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
* 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

#####  使用场景，项目中使用
程序的日志应用、配置对象的读取、数据库连接池、线程池、负载均衡器、工具类
缓存、日志对象、对话框、打印机、显卡的驱动程序对象

项目中有个打印面单的功能，设计就是单例模式，不能起两个打印程序


### 2.简单工厂
##### 定义
在简单工厂模式中，可以根据参数的不同返回不同类的实例

##### 解决问题
将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易，从而避免了在客户端代码中显式指定，实现了解耦

##### 优点
* 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
* 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
##### 缺点
* 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
* 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
* 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构

##### 应用场景
* 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；
* 当工厂类负责创建的对象（具体产品）比较少时

### 3.工厂模式
##### 定义
通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象

##### 作用
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类

##### 解决的问题
解决简单工厂添加新产品得修改工厂类，违背了开放关闭原则的问题

##### 优点
* 更符合开-闭原则
新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构。
简单工厂模式的工厂类使用静态工厂方法

* 总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

##### 缺点
* 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
* 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
* 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
* 一个具体工厂只能创建一种具体产品




### 4.抽象工厂

##### 定义
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

##### 作用
允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦

##### 解决问题
每个工厂只能创建一类产品

##### 优点
* 更符合开-闭原则
新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构

##### 缺点
在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便

##### 应用场景
* 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。
* 这个系统有多个系列产品，而系统中只消费其中某一系列产品
* 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。

### 5.建造者
##### 定义
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

##### 作用
隐藏对象内部的建造过程和细节
用户只需要给出指定复杂对象的类型和内容
建造者模式负责按顺序创建复杂对象

##### 解决问题
方便用户创建复杂的对象（不需要知道实现过程）
代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

##### 优点
* 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
* 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
* 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
* 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”

##### 缺点
* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
* 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大

##### 应用场景
* 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
* 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品

##### 模式应用
在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物

------

# 结构型模式

### 6.适配器
##### 定义
提供一个适配器Adapter,用于包装不兼容接口的对象

##### 作用
把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作

##### 解决问题
原本由于接口不兼容而不能一起工作的那些类可以在一起工作

##### 优点
* 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
* 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
* 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”

##### 缺点
###### 类适配器模式的缺点如下：
对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。
###### 对象适配器模式的缺点如下：
与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂

##### 应用场景
* 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
* 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们


### 7.代理模式

##### 定义
给某一个对象提供一个代 理，并由代理对象控制对原对象的引用

##### 作用
通过引入代理对象的方式来间接访问目标对象

##### 解决问题
防止直接访问目标对象给系统带来的不必要复杂性。

##### 优点
协调调用者和被调用者，降低了系统的耦合度
代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用
##### 缺点
由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；
实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度


##### 应用场景
![](/assets/944365-6ab7f58ee0497fdd.png)


### 8.外观模式

##### 定义
定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。

##### 作用
实现客户类与子系统类的松耦合
降低原有系统的复杂度
提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能

##### 解决问题
避免了系统与系统之间的高耦合度
使得复杂的子系统用法变得简单

##### 优点
* 降低了客户类与子系统类的耦合度，实现了子系统与客户之间的松耦合关系
* 外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单
##### 缺点
* 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”
* 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。


##### 应用场景
* 要为一个复杂的子系统对外提供一个简单的接口
* 提供子系统的独立性
* 客户程序与多个子系统之间存在很大的依赖性


### 9.装饰模式

##### 定义
动态地给一个对象增加装饰一些额外的职责(Responsibility)

##### 作用
通过引入代理对象的方式来间接访问目标对象

##### 解决问题
防止直接访问目标对象给系统带来的不必要复杂性。

##### 优点
协调调用者和被调用者，降低了系统的耦合度
代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用
##### 缺点
由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；
实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度


##### 应用场景
![](/assets/944365-6ab7f58ee0497fdd.png)


-------
# 行为型模式
### 10.策略模式

##### 定义
定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 & 让算法可在不影响客户端的情况下发生变化
> 简单来说：准备一组算法 & 将每一个算法封装起来，让外部按需调用 & 使得互换

##### 作用
将算法的责任和本身进行解耦，使得：

算法可独立于使用外部而变化
客户端方便根据外部条件选择不同策略来解决不同问题

> 策略模式仅仅封装算法（包括添加 & 删除），但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定

##### 优点
* 策略类之间可以自由切换
由于策略类都实现同一个接口，所以使它们之间可以自由切换。
* 易于扩展
增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，* 符合“开闭原则“
避免使用多重条件选择语句（if else），充分体现面向对象设计思想。
##### 缺点
* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量


##### 应用场景
动态选择多种复杂行为
该行为
1.复杂的算法 / 数据结构
2.类的行为 / 方法

### 11.模板方法模式

##### 定义
定义一个模板结构，将某些步骤延迟到子类去实现

##### 作用
在不改变模板结构的前提下在子类中重新定义模板中某些步骤的内容

##### 解决问题
* 提高代码复用性
将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
* 实现了反向控制
通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 & 符合“开闭原则”

##### 优点
* 提高代码复用性
将相同部分的代码放在抽象的父类中
* 提高了拓展性
将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为
* 实现了反向控制
通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制 & 符合“开闭原则
##### 缺点
引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度


##### 应用场景
* 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；
* 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；
* 控制子类的扩展


### 12.观察者模式

##### 定义
使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

##### 优点


观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
观察者模式在观察目标和观察者之间建立一个抽象的耦合。
观察者模式支持广播通信。
观察者模式符合“开闭原则”的要求。
##### 缺点

如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
##### 适用环境
在以下情况下可以使用观察者模式：

一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
一个对象必须通知其他对象，而并不知道这些对象是谁。
需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
##### 模式应用
观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式

##### 观察者两种模式
* 推模型
* 拉模型
拉模型 传递主题对象
```java
public interface Observer {
    /**
     * 更新接口
     * @param subject 传入主题对象，方面获取相应的主题对象的状态
     */
    public void update(Subject subject);
}
```

```java
public class ConcreteObserver implements Observer {
    //观察者的状态
    private String observerState;
    
    @Override
    public void update(Subject subject) {
        /**
         * 更新观察者的状态，使其与目标的状态保持一致
         */
        observerState = ((ConcreteSubject)subject).getState();
        System.out.println("观察者状态为："+observerState);
    }

}
```

```java
public abstract class Subject {
    /**
     * 用来保存注册的观察者对象
     */
    private    List<Observer> list = new ArrayList<Observer>();
    /**
     * 注册观察者对象
     * @param observer    观察者对象
     */
    public void attach(Observer observer){
        
        list.add(observer);
        System.out.println("Attached an observer");
    }
    /**
     * 删除观察者对象
     * @param observer    观察者对象
     */
    public void detach(Observer observer){
        
        list.remove(observer);
    }
    /**
     * 通知所有注册的观察者对象
     */
    public void nodifyObservers(){
        
        for(Observer observer : list){
            observer.update(this);
        }
    }
}
```

































































































































































































































































































































