# 创建型模式

### 1.单例模式

##### 定义
单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，提供全局访问

##### 解决问题（为什么使用单例模式）
一则解决多线程并发访问的问题，避免对资源的多重占用、同时操作
二则节约CPU资源及内存资源，提交系统运行的效率，提高系统性能

##### 优点
* 提供了对唯一实例的受控访问；
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；
* 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式；

##### 缺点
* 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。
* 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失

##### 适用场景
* 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
* 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

#####  使用场景，项目中使用
程序的日志应用、配置对象的读取、数据库连接池、线程池、负载均衡器、工具类
缓存、日志对象、对话框、打印机、显卡的驱动程序对象

项目中有个打印面单的功能，设计就是单例模式，不能起两个打印程序


### 2.简单工厂
##### 定义
在简单工厂模式中，可以根据参数的不同返回不同类的实例

##### 解决问题
将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易，从而避免了在客户端代码中显式指定，实现了解耦

##### 优点
* 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
* 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
##### 缺点
* 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
* 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
* 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构

##### 应用场景
* 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；
* 当工厂类负责创建的对象（具体产品）比较少时

### 3.工厂模式
##### 定义
通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象

##### 作用
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类

##### 解决的问题
解决简单工厂添加新产品得修改工厂类，违背了开放关闭原则的问题

##### 优点
* 更符合开-闭原则
新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构。
简单工厂模式的工厂类使用静态工厂方法

* 总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

##### 缺点
* 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
* 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
* 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
* 一个具体工厂只能创建一种具体产品




### 4.抽象工厂

##### 定义
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

##### 作用
允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦

##### 解决问题
每个工厂只能创建一类产品

##### 优点
* 更符合开-闭原则
新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构

##### 缺点
在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便

##### 应用场景
* 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。
* 这个系统有多个系列产品，而系统中只消费其中某一系列产品
* 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。

### 5.建造者
##### 定义
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

##### 作用
隐藏对象内部的建造过程和细节
用户只需要给出指定复杂对象的类型和内容
建造者模式负责按顺序创建复杂对象

##### 解决问题
方便用户创建复杂的对象（不需要知道实现过程）
代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

##### 优点
* 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
* 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
* 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
* 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”

##### 缺点
* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
* 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大

##### 应用场景
* 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
* 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品

##### 模式应用
在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物

------

# 结构型模式

### 6.适配器
##### 定义
提供一个适配器Adapter,用于包装不兼容接口的对象

##### 作用
把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作

##### 解决问题
原本由于接口不兼容而不能一起工作的那些类可以在一起工作

##### 优点
* 更符合开-闭原则
新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构

##### 缺点
在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便

##### 应用场景
* 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。
* 这个系统有多个系列产品，而系统中只消费其中某一系列产品
* 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。






